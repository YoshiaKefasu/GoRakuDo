---
import { getCollection, type CollectionEntry } from "astro:content"
import Head from "../../components/public-components/HeadSEO.astro"
import Breadcrumb from "../../components/public-components/Breadcrumb.astro"
import Navbar from "../../components/public-components/Navbar.vue"
import { AIRecommendations } from "../../components/docs/ai-recommendations"
import {
  getRelatedContent,
  getContentWithSimpleAIMetadata,
  loadAndEnhanceRecommendations,
  convertPostsToPostInfo,
  processPostWithOptimization,
} from "../../utils/ai-content"
import { generateInternalLinks, analyzeContent } from "../../utils/ai-content"
import {
  loadMetadata,
  getSEOFromMetadata,
  getRecommendationsFromMetadata,
} from "../../utils/metadata-loader"
import {
  resolveContentPath,
  getCollectionMetadata,
} from "../../utils/content-path-resolver"
import { MIND_MAP_CONFIG, MindMapUtils } from "../../components/mind-map/mind-map-config"

// Import global CSS with essential variables and base styles
import "../../styles/global.css"
// Import post-specific styles with Tailwind v4 optimization
import "../../styles/docs/[slug].css"
// Import word internal links styles (replaces inline system)
import "../../styles/docs/word-internal-links.css"

// Generate static paths for all docs posts
export async function getStaticPaths() {
  const posts = await getCollection("docs")

  return posts.map((post) => ({
    params: { slug: post.slug },
    props: { post },
  }))
}

// Get the post from props with explicit type casting
const { post } = Astro.props as { post: CollectionEntry<"docs"> }

// Smart error handling - redirect to docs listing if post not found
if (!post) {
  return Astro.redirect("/docs?error=post-not-found")
}

// Dynamic content path resolution for SEO
const resolvedPath = resolveContentPath(post)
const collectionMetadata = getCollectionMetadata("docs") // Default to docs for backward compatibility

// SEO data with proper optional prop handling
const seoData = {
  title: post.data.title,
  description: String(post.data.description),
  canonicalUrl: `https://gorakudo.org${resolvedPath.path}`,
  pageType: "article" as const,
  authorName: String(post.data.author),
  publishedDate: String(post.data.publishedDate),
}

// Helper function to format date
function formatDate(dateString: string): string {
  const options: Intl.DateTimeFormatOptions = {
    year: "numeric",
    month: "long",
    day: "numeric",
  }
  return new Date(dateString).toLocaleDateString("id-ID", options)
}

// Prepare post data for script section with dynamic path resolution
const postData = {
  title: post.data.title,
  description: post.data.description,
  publishedDate: post.data.publishedDate,
  author: post.data.author,
  readTime: post.data.readTime,
  difficulty: post.data.difficulty,
  body: post.body,
  slug: post.slug,
  resolvedPath: resolvedPath.path,
  collectionMetadata: {
    displayName: collectionMetadata.displayName,
    icon: collectionMetadata.icon,
    basePath: collectionMetadata.basePath,
  },
}

// Generate optimized recommendations for this post (checks for existing metadata first)
let relatedContent: any = null
let internalLinks: any = null
let enhancedContent: string = post.body

// Mind map integration
let currentBranch: any = null
let relatedBranches: any[] = []

try {
  // Determine current branch based on post content
  const mindMapData = MindMapUtils.exportData()
  
  // Analyze post content to find matching mind map branch
  const postContent = post.data.title + " " + (post.data.description || "")
  const postKeywords = postContent.toLowerCase().split(/\s+/)
  
  // Find best matching branch based on keywords
  let bestMatch = { branch: null, score: 0 }
  
  Object.values(mindMapData.branches).forEach((branch: any) => {
    const branchKeywords = branch.keywords.map((k: string) => k.toLowerCase())
    const matchScore = postKeywords.filter((keyword) =>
      branchKeywords.some(
        (branchKeyword) =>
          branchKeyword.includes(keyword) || keyword.includes(branchKeyword)
      )
    ).length
    
    if (matchScore > bestMatch.score) {
      bestMatch = { branch, score: matchScore }
    }
  })
  
  if (bestMatch.branch) {
    currentBranch = bestMatch.branch
    relatedBranches = MindMapUtils.getRelatedBranches(bestMatch.branch.id)
      .map((id) => MindMapUtils.getBranch(id))
      .filter(Boolean)
  }
  
  // Use optimized post processor that checks for existing metadata
  const result = await processPostWithOptimization(post)

  relatedContent = result.relatedContent
  internalLinks = result.internalLinks
  enhancedContent = result.enhancedContent

  if (result.usedExistingMetadata) {
    console.log(
      `‚è≠Ô∏è  Used existing metadata for "${post.slug}" (${result.processingTime}ms)`
    )
  } else {
    console.log(
      `ü§ñ Generated new recommendations for "${post.slug}" (${result.processingTime}ms)`
    )
  }
} catch (error) {
  console.warn(`‚ö†Ô∏è Failed to process post "${post.slug}":`, error)
}
---

<!doctype html>
<html lang="id">
  <head>
    <Head {...seoData} aiPageType="post" enableAIOptimizations={true} />

    <!-- Preload critical resources for better performance -->
    <link
      rel="preload"
      href="https://cdn.jsdelivr.net/npm/marked/marked.min.js"
      as="script"
    />
    <link rel="preload" href="/src/scripts/core/post-script.js" as="script" />

    <!-- Fonts with display=swap for better performance -->
    <link
      href="https://fonts.googleapis.com/css2?family=Yuji+Syuku&family=Inter:wght@300;400;500;600;700&family=Lora:wght@400;600&family=Cedarville+Cursive&display=swap"
      rel="stylesheet"
    />

    <!-- Core: Always load marked for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  </head>

  <body>
    <!-- Navigation -->
    <Navbar client:visible />

    <!-- Decorative Background Elements -->
    <canvas id="waveCanvas" class="wave-canvas" aria-hidden="true"></canvas>

    <div class="stars" aria-hidden="true">
      <div class="star" style="top: 10%; left: 20%; animation-delay: 0s;"></div>
      <div class="star" style="top: 20%; right: 20%; animation-delay: 1s;"></div>
      <div class="star" style="top: 30%; left: 80%; animation-delay: 2s;"></div>
      <div class="star" style="bottom: 30%; left: 10%; animation-delay: 1.5s;"></div>
      <div class="star" style="bottom: 20%; right: 30%; animation-delay: 0.5s;"></div>
      <div class="star" style="top: 60%; left: 15%; animation-delay: 2.5s;"></div>
      <div class="star" style="top: 80%; right: 20%; animation-delay: 1.8s;"></div>
      <div class="star" style="bottom: 40%; right: 60%; animation-delay: 0.8s;"></div>
    </div>

    <!-- Main Content -->
    <main class="post-page" role="main">
      <div class="post-container">
        <!-- Breadcrumb Navigation and Related Content Container -->
        <div class="breadcrumb-with-related">
          <Breadcrumb post={post} showMindMap={true} className="breadcrumb-transparent" />
        </div>

        <!-- Article Header -->
        <header class="post-header">
          <h1 class="post-title">{post.data.title}</h1>

          <div class="post-meta" aria-label="Post metadata">
            <time class="post-date" datetime={post.data.publishedDate}>
              {formatDate(post.data.publishedDate)}
            </time>
            <span class="post-author">by {post.data.author}</span>
          </div>

          <div class="post-tags">
            <span
              class="difficulty-badge difficulty-{post.data.difficulty}"
              aria-label="Difficulty level: {post.data.difficulty}">
              {post.data.difficulty}
            </span>
          </div>
        </header>

        <!-- Article Content -->
        <article class="post-content" id="postContent" aria-label="Post content" set:html={enhancedContent} />

        <!-- Post Actions -->
        <footer class="post-actions">
          <a
            href={collectionMetadata.basePath}
            class="back-to-docs"
            aria-label={`Kembali ke ${collectionMetadata.displayName}`}>
            <svg
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              aria-hidden="true">
              <path d="M19 12H5M12 19l-7-7 7-7"></path>
            </svg>
            Kembali ke {collectionMetadata.displayName}
          </a>
          <div class="share-buttons">
            <button class="share-btn" onclick="sharePost()" aria-label="Bagikan post ini">
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
                aria-hidden="true">
                <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                <polyline points="16,6 12,2 8,6"></polyline>
                <line x1="12" y1="2" x2="12" y2="15"></line>
              </svg>
              Bagikan
            </button>
          </div>
        </footer>

        {/* AI-Powered Content Recommendations Section */}
        {
          relatedContent && (
            <section
              class="ai-recommendations-section"
              aria-label="Rekomendasi konten terkait">
              <AIRecommendations
                relatedContent={relatedContent}
                maxRecommendations={3}
                showHeader={true}
                className=""
                showFallback={true}
              />
            </section>
          )
        }
      </div>
    </main>

    <!-- Scripts Section - Organized and Optimized -->
    <script is:inline src="/src/scripts/core/post-script.js"></script>
    <script src="/src/scripts/ui/post-skeleton-loader.js" is:inline></script>

    <!-- Main Application Script -->
    <script define:vars={{ postData, enhancedContent }}>
      // ========== GLOBAL VARIABLES ==========
      let enhancedContentLoaded = false

      // ========== UTILITY FUNCTIONS ==========

      // Share functionality with dynamic path support
      function sharePost() {
        const shareUrl = postData?.resolvedPath
          ? `${window.location.origin}${postData.resolvedPath}`
          : window.location.href

        if (navigator.share) {
          navigator.share({
            title: postData?.title || "GoRakuDo Post",
            text: postData?.description || "Check out this post from GoRakuDo",
            url: shareUrl,
          })
        } else {
          // Fallback: copy to clipboard
          navigator.clipboard.writeText(shareUrl).then(() => {
            alert("Link berhasil disalin ke clipboard!")
          })
        }
      }

      // Reading progress indicator
      function addReadingProgress() {
        const progressBar = document.createElement("div")
        progressBar.className = "reading-progress"
        progressBar.setAttribute("role", "progressbar")
        progressBar.setAttribute("aria-label", "Reading progress")
        progressBar.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 0%;
          height: 3px;
          background: linear-gradient(90deg, #8b5dff, #7b4def);
          z-index: 1000;
          transition: width 0.1s ease;
        `
        document.body.appendChild(progressBar)

        window.addEventListener("scroll", () => {
          const scrollTop = window.pageYOffset
          const docHeight = document.body.scrollHeight - window.innerHeight
          const scrollPercent = (scrollTop / docHeight) * 100
          progressBar.style.width = scrollPercent + "%"
          progressBar.setAttribute("aria-valuenow", Math.round(scrollPercent))
        })
      }

      // Enhanced loading with performance optimizations
      async function loadEnhancements() {
        try {
          console.log("‚ö° Loading enhancements...")

          // Add reading progress
          addReadingProgress()

          // Set up error handling
          window.addEventListener("error", function (e) {
            console.error("Content load error:", e.error)
          })

          window.addEventListener("unhandledrejection", function (e) {
            console.error("Unhandled promise rejection:", e.reason)
          })

          // Performance optimizations
          if ("requestIdleCallback" in window) {
            requestIdleCallback(() => {
              console.log("‚ö° Idle time optimizations applied")
            })
          }

          console.log("‚úÖ Enhancements loaded successfully")
        } catch (error) {
          console.error("Failed to load enhancements:", error)
        }
      }

      // ========== CONTENT RENDERING ==========

      // Initialize enhanced content
      if (enhancedContent) {
        window.enhancedContent = enhancedContent
        enhancedContentLoaded = true
        console.log("ü§ñ Enhanced content with internal links loaded")
      }

      // Render post content
      function renderPostContent() {
        if (!postData) return

        const content = window.enhancedContent || postData.body
        const postContent = document.getElementById("postContent")

        if (!postContent) return

        // Show skeleton loading
        showPostSkeleton(postContent)

        // Configure marked for markdown rendering
        marked.setOptions({
          highlight: function (code, lang) {
            return `<pre><code class="language-${lang}">${code}</code></pre>`
          },
          breaks: true,
          gfm: true,
        })

        // Render content with minimal delay
        setTimeout(() => {
          const renderedHTML = marked.parse(content)
          postContent.innerHTML = renderedHTML
          hidePostSkeleton(postContent)

          // Load enhancements after content is rendered
          loadEnhancements()
        }, 100)
      }

      // ========== SKELETON LOADING ==========

      function showPostSkeleton(container) {
        if (!container) return

        container.innerHTML = `
          <div class="post-content skeleton-content">
            <div class="skeleton-content-header">
              <div class="skeleton-content-title"></div>
              <div class="skeleton-content-meta">
                <div class="skeleton-content-author"></div>
                <div class="skeleton-content-date"></div>
                <div class="skeleton-content-read-time"></div>
              </div>
            </div>
            <div class="skeleton-content-body">
              <div class="skeleton-paragraph"></div>
              <div class="skeleton-paragraph"></div>
              <div class="skeleton-paragraph"></div>
              <div class="skeleton-paragraph"></div>
              <div class="skeleton-paragraph short"></div>
              <div class="skeleton-paragraph"></div>
              <div class="skeleton-paragraph"></div>
              <div class="skeleton-paragraph short"></div>
            </div>
            <div class="skeleton-content-tags">
              <div class="skeleton-content-tag"></div>
              <div class="skeleton-content-tag"></div>
              <div class="skeleton-content-tag"></div>
            </div>
          </div>
        `
        container.classList.add("skeleton-loading")
        console.log("‚úÖ Post skeleton shown")
      }

      function hidePostSkeleton(container) {
        if (!container) return

        container.classList.remove("skeleton-loading")
        container.classList.add("skeleton-fade-in")

        setTimeout(() => {
          container.classList.remove("skeleton-fade-in")
        }, 500)

        console.log("‚úÖ Post skeleton hidden")
      }

      // ========== INITIALIZATION ==========

      // Set default preferences
      if (typeof localStorage !== "undefined") {
        if (!localStorage.getItem("setting_aggressiveLoading")) {
          localStorage.setItem("setting_aggressiveLoading", "true")
        }
        if (!localStorage.getItem("threshold_syntaxHighlighting")) {
          localStorage.setItem("threshold_syntaxHighlighting", "500")
        }
        if (!localStorage.getItem("threshold_readingProgress")) {
          localStorage.setItem("threshold_readingProgress", "300")
        }
        if (!localStorage.getItem("threshold_errorHandling")) {
          localStorage.setItem("threshold_errorHandling", "1000")
        }
      }

      // Initialize when DOM is ready
      document.addEventListener("DOMContentLoaded", function () {
        renderPostContent()
      })
    </script>
  </body>
</html>
